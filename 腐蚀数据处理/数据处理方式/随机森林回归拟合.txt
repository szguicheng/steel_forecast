# import pandas as pd
# import numpy as np
# import matplotlib.pyplot as plt
# from sklearn.model_selection import GridSearchCV, train_test_split
# from sklearn.ensemble import RandomForestRegressor
# from sklearn.preprocessing import StandardScaler
# from sklearn.metrics import r2_score, mean_squared_error
# from matplotlib.ticker import MultipleLocator
# import math
# # 加载CSV文件
# df = pd.read_csv(r'C:\Users\asus\Desktop\merge_all2.csv')
# X = df[['Mn','S','Si','Cu','Ave_Temp','Ave_RH','Sunshine','Ultraviolet','SO2','Cl','Time']]
# y = df['Vcorr']
# # 划分数据集为训练集和测试集
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
# # 归一化特征
# scaler = StandardScaler()
# X_train_scaled = scaler.fit_transform(X_train)
# X_test_scaled = scaler.transform(X_test)
# # 定义梯度提升树回归模型和参数网格
# param_grid = {
#     'n_estimators': [100, 150, 200, 300, 400, 500, 600, 700],
#     'max_depth': [3, 5, 8, 10, 12, 15, 20, None]
# }
# rf_regressor = RandomForestRegressor()
# # 使用网格搜索寻找最佳模型
# grid_search = GridSearchCV(rf_regressor, param_grid, cv=5)
# grid_search.fit(X_train_scaled, y_train)
# # 获取最佳参数
# best_params = grid_search.best_params_
# print("Best Parameters:", best_params)
# # # 使用最佳模型进行回归预测
# final_RF_regressor = RandomForestRegressor(**best_params)
# final_RF_regressor.fit(X_train_scaled,y_train)
# # 使用最佳模型进行预测
# y_train_pred = final_RF_regressor.predict(X_train_scaled)
# y_test_pred = final_RF_regressor.predict(X_test_scaled)
# # 评估模型
# train_r2 = r2_score(y_train, y_train_pred)
# train_rmse = math.sqrt(mean_squared_error(y_train, y_train_pred))
# test_r2 = r2_score(y_test, y_test_pred)
# test_rmse = math.sqrt(mean_squared_error(y_test, y_test_pred))
# print("训练集上的R²：", train_r2)
# print("训练集上的RMSE：", train_rmse)
# print("测试集上的R²：", test_r2)
# print("测试集上的RMSE：", test_rmse)
# # 创建图形
# fig, ax = plt.subplots()
# # 绘制训练集和测试集的预测结果
# ax.scatter(y_train, y_train_pred, c='cornflowerblue', label='Training set',alpha=0.6)
# ax.scatter(y_test, y_test_pred, c='red', label='Test set',alpha=0.5)
# ax.set_xlabel('Measured corrosion rate (\u03BCm/a)',fontsize=19)
# ax.set_ylabel('Predicted corrosion rate (\u03BCm/a)',fontsize=19)
# plt.rcParams["axes.linewidth"] = 20                                          # 设置边框粗细
# # 设置次刻度线长度和个数
# x = np.linspace(0, 60, 7)
# y = np.linspace(0, 60, 7)
# # 设置x轴和y轴的次刻度间隔（每个主刻度之间的次刻度）
# x_minor_locator = MultipleLocator(5)                                         # 设置x轴次刻度间隔为5
# y_minor_locator = MultipleLocator(5)                                         # 设置y轴次刻度间隔为5
# # 将刻度间隔应用到x和y轴
# ax.xaxis.set_minor_locator(x_minor_locator)
# ax.yaxis.set_minor_locator(y_minor_locator)
# # 设置刻度字体大小为16
# ax.tick_params(axis='both', labelsize=16)
# # 设置主刻度线的长度
# ax.tick_params(axis='both', which='major', length=6, width=1.3)                    # 设置主刻度线长度为5
# # 设置次刻度线的长度
# ax.tick_params(axis='both', which='minor', length=4, width=1.1)                    # 设置次刻度线长度为4
# # 创建一组x和y坐标，这些坐标构成了对角线
# x2 = [0, 60]
# y2 = [0, 60]
# # 使用plot函数绘制对角线,解决对角线显示不完全的问题
# ax.set_xlim(0, 60)
# ax.set_ylim(0, 60)
# ax.plot(x2,y2,'red')
# ax.text(56.2,3,'RF',fontsize=17)
# ax.legend(fontsize=17,loc='upper left',frameon=False)
# # 设置边框粗细
# border_width = 1.6  # 指定边框的粗细
# ax = plt.gca()  # 获取当前轴
# for pos in ['top', 'bottom', 'right', 'left']:
#     ax.spines[pos].set_linewidth(border_width)
# plt.rcParams['font.sans-serif']=['Times New Roman']
# plt.tight_layout()
# plt.savefig(r'C:\Users\asus\Desktop\RF6.tif',dpi=600)
# plt.show()