# 岭回归（增加次刻度）
# import pandas as pd
# import numpy as np
# from sklearn.model_selection import GridSearchCV, train_test_split
# from sklearn.linear_model import Ridge
# from sklearn.preprocessing import StandardScaler
# from sklearn.metrics import r2_score, mean_squared_error
# import matplotlib.pyplot as plt
# from matplotlib.ticker import MultipleLocator
# from IPython.display import display
# import math
# # 加载CSV文件
# df = pd.read_csv(r'C:\Users\asus\Desktop\merge_all2.csv')
# X = df[['Mn','S','Si','Cu','Ave_Temp','Ave_RH','Sunshine','Ultraviolet','SO2','Salinity']]
# y = df['Vcorr']
# # 划分数据集为训练集和测试集
# X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)
# # 归一化特征
# scaler = StandardScaler()
# X_train_scaled = scaler.fit_transform(X_train)
# X_test_scaled = scaler.transform(X_test)
# # 定义岭回归模型和参数网格
# param_grid = {
#     'alpha': [0.001, 0.01, 0.05, 0.1, 0.5, 1,10,100]
# }
# ridge_regressor = Ridge()
# # 使用网格搜索寻找最佳模型
# grid_search = GridSearchCV(ridge_regressor, param_grid, cv=5)
# grid_search.fit(X_train_scaled, y_train)
# # 输出最佳模型的参数组合
# best_params = grid_search.best_params_
# print("Best Parameters:", best_params)
# results = pd.DataFrame(grid_search.cv_results_)
# display(results.head().T)
# # 使用最佳模型进行支持向量机回归预测
# final_Ridge_regressor = Ridge(**best_params)
# final_Ridge_regressor.fit(X_train_scaled,y_train)
# # 在训练集上进行预测
# y_train_scaled_pred = final_Ridge_regressor.predict(X_train_scaled)
# # 在测试集上进行预测
# y_test_scaled_pred = final_Ridge_regressor.predict(X_test_scaled)
# # 计算训练集上的R²和RMSE
# train_r2 = r2_score(y_train,y_train_scaled_pred)
# train_rmse = math.sqrt(mean_squared_error(y_train,y_train_scaled_pred))
# # 计算测试集上的R²和RMSE
# test_r2 = r2_score(y_test,y_test_scaled_pred)
# test_rmse = math.sqrt(mean_squared_error(y_test,y_test_scaled_pred))
# print("训练集上的R²：", train_r2)
# print("训练集上的RMSE：", train_rmse)
# print("测试集上的R²：", test_r2)
# print("测试集上的RMSE：", test_rmse)
# # 创建图形
# fig, ax = plt.subplots()
# # 绘制训练集和测试集的预测结果
# ax.scatter(y_train, y_train_scaled_pred, c='cornflowerblue', label='Training set',alpha=0.6)
# ax.scatter(y_test, y_test_scaled_pred, c='red', label='Test set',alpha=0.5)
# ax.set_xlabel('Measured corrosion rate (\u03BCm/a)',fontsize=19)
# ax.set_ylabel('Predicted corrosion rate (\u03BCm/a)',fontsize=19)
# plt.rcParams["axes.linewidth"] = 20                                          # 设置边框粗细
# # 设置次刻度线长度和个数
# x = np.linspace(0, 60, 7)
# y = np.linspace(0, 60, 7)
# # 设置x轴和y轴的次刻度间隔（每个主刻度之间的次刻度）
# x_minor_locator = MultipleLocator(5)                                        # 设置x轴次刻度间隔为5
# y_minor_locator = MultipleLocator(5)                                        # 设置y轴次刻度间隔为5
# # 将刻度间隔应用到x和y轴
# ax.xaxis.set_minor_locator(x_minor_locator)
# ax.yaxis.set_minor_locator(y_minor_locator)
# # 设置刻度字体大小为16
# ax.tick_params(axis='both', labelsize=16)
# # 设置主刻度线的长度
# ax.tick_params(axis='both', which='major', length=6, width=1.3)                    # 设置主刻度线长度为5
# # 设置次刻度线的长度
# ax.tick_params(axis='both', which='minor', length=4, width=1.1)                    # 设置次刻度线长度为4
# # 创建一组x和y坐标，这些坐标构成了对角线
# x2 = [0, 60]
# y2 = [0, 60]
# # 使用plot函数绘制对角线,解决对角线显示不完全的问题
# ax.set_xlim(0, 60)
# ax.set_ylim(0, 60)
# ax.plot(x2,y2,'red')
# ax.text(52,3,'RR',fontsize=17)
# ax.legend(fontsize=17,loc='upper left',frameon=False)
# plt.rcParams['font.sans-serif']=['Times New Roman']
# plt.tight_layout()
# plt.savefig(r'C:\Users\asus\Desktop\RR_加粗.png')
# plt.show()